/* Author: Thomas Del Prete */
// VERY IMPORTANTE: Use "g++ -o cup cup.cpp" to compile!

#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <time.h>
#include <vector>
#include <algorithm>
#include <string>
#include <unordered_set>
#include <cmath>
#include <sstream>
#include <fstream>
#include <array>
#include <ctime>
#include <cstdlib>

//TODO
// take "DIMENSION" and put it in array "nodes" size
// take nodes with coords and put them in the nodes array
// to do that start from the 7th row, each row will be a node
// first compute a random on the nodes
// then compute 2 otp on each iteration of the annealing
// reference: http://www.cleveralgorithms.com/nature-inspired/physical/simulated_annealing.html
// take input file and all other parameters from terminal

// max_iterations = 2000;

float nodes[2000][3]; //MAX INPUT NODES 2000. [id, x, y]

int myrandom (int i) {
  return std::rand()%i;
}

int path_cost (float nodes_array[][3], int nodes_number){
  int cost = 0;
  for (int i = 0; i < nodes_number; ++i){
    if (i == (nodes_number - 1)) {
      cost += sqrt( pow((nodes_array[i][1] + nodes_array[0][1]), 2) + pow((nodes_array[i][2] + nodes_array[0][2]), 2) );
    } else {
      cost += sqrt( pow((nodes_array[i][1] + nodes_array[i+1][1]), 2) + pow((nodes_array[i][2] + nodes_array[i+1][2]), 2) );
    }
  }
  return cost;
}

void otp2 (float nodes_array[][3], int nodes_number){
  int pos_1 = (std::rand() % nodes_number);
  int pos_2 = (std::rand() % nodes_number);
  if (pos_1 > pos_2) {
    int tmp = pos_2;
    pos_2 = pos_1;
    pos_1 = tmp;
  }
  std::reverse(&nodes_array[pos_1], &nodes_array[pos_2]);
}

void should_accept (float nodes_array[][3], int nodes_number, float temp){ //generates 2otp from current, compares them and picks the optimal one (at the end, input array will contain optimal). Also updates the best.
  float otp_nodes[nodes_number][3];
  std::copy(&nodes_array[0][0], &nodes_array[0][0]+nodes_number*3,&otp_nodes[0][0]);
  otp2(otp_nodes, nodes_number);
  int cost = path_cost(nodes_array, nodes_number);
  int otp_cost = path_cost(otp_nodes, nodes_number);
  // std::cout << cost << " " << otp_cost << std::endl;
  if (otp_cost <= cost) {
    // std::cout << "L E S S" << '\n';
    std::copy(&otp_nodes[0][0], &otp_nodes[0][0]+nodes_number*3,&nodes_array[0][0]);
  } else {
    // std::cout << "M O R E" << '\n';
    if ( exp((cost - otp_cost)/temp) > ((double)rand()/(RAND_MAX)) ){
      // std::cout << "M O R E  A C C E P T" << '\n';
      std::copy(&otp_nodes[0][0], &otp_nodes[0][0]+nodes_number*3,&nodes_array[0][0]);
    }
  }
}

int main () {

  int nodes_number;
  float temperature = 1000000.0;
  float temp_change = 0.98;

  time_t seed = std::time(0); // seed used for random generated by time
  std::srand(unsigned(seed)); // srand using known seed

/////////////////////////////////TAKING INPUT//////////////////////////////////
  std::string line;
  int line_count = 0;
  std::ifstream myfile ("ch130.tsp");
  if (myfile.is_open()) {
    while ( getline (myfile,line) ) {
      if (line_count == 3) { //when line_count=3 get dimension
        std::istringstream iss (line); //used to then parse the line
        std::string dump;
        iss >> dump >> nodes_number;
      }
      if (line_count >= 7) { //when line_count=7 start getting nodes
        std::istringstream iss (line); //used to then parse the line
        int node_id;
        float x_coord;
        float y_coord;
        iss >> node_id >> x_coord >> y_coord;
        nodes[node_id - 1][0] = node_id;
        nodes[node_id - 1][1] = x_coord;
        nodes[node_id - 1][2] = y_coord;
      }
      ++line_count;
    }
    myfile.close();
  } else {
    std::cout << "Unable to open file";
  }
  // //          nodes array print            //
  //
  //   for (int i = 0; i < nodes_number; ++i)
  //   {
  //       for (int j = 0; j < 3; ++j)
  //       {
  //           std::cout << nodes[i][j] << " ";
  //       }
  //       std::cout << std::endl;
  //   }
  // //                                       //

////////////////////////// CREATE FIRST RANDOM TOUR /////////////////////////////

  float shuffled_nodes[nodes_number][3];
  std::copy(&nodes[0][0], &nodes[0][0]+nodes_number*3,&shuffled_nodes[0][0]);
  std::random_shuffle ( &shuffled_nodes[0], &shuffled_nodes[nodes_number], myrandom);

  std::cout << "random cost: " << path_cost(shuffled_nodes, nodes_number) << std::endl;
  //          nodes array print            //

    for (int i = 0; i < nodes_number; ++i)
    {
        for (int j = 0; j < 3; ++j)
        {
            std::cout << shuffled_nodes[i][j] << " ";
        }
        std::cout << std::endl;
    }
  //                                       //

  // std::cout << "-------------------------------------------------------------" << std::endl;
  // std::cout << "seed: " << seed << std::endl;
  // std::cout << "-------------------------------------------------------------" << std::endl;

////////////////////////////////// ANNEALING //////////////////////////////////

  int best_cost = path_cost(shuffled_nodes, nodes_number);
  float best[2000][3];
  std::copy(&nodes[0][0], &nodes[0][0]+nodes_number*3, &shuffled_nodes[0][0]);
  int shuffled_cost;

  for (float i = temperature; i > 0; i -= temp_change){
    should_accept(shuffled_nodes, nodes_number, temperature);
    shuffled_cost = path_cost(shuffled_nodes, nodes_number);
    // shuffled nodes better than solution?
    if (shuffled_cost <= best_cost) {
      std::copy(&shuffled_nodes[0][0], &shuffled_nodes[0][0]+nodes_number*3,&best[0][0]);
      best_cost = shuffled_cost;
    }
  }

  std::cout << "-------------------------------------------------------------" << std::endl;
  std::cout << "best cost: " << best_cost << std::endl;
  std::cout << "best solution: " << std::endl;
 //          nodes array print            //

   for (int i = 0; i < nodes_number; ++i)
   {
       for (int j = 0; j < 3; ++j)
       {
           std::cout << best[i][j] << " ";
       }
       std::cout << std::endl;
   }
 //                                       //


  return 0;
}
